<!DOCTYPE html>
<html>
<head>
<title>Detailed Hoop Model - V4 with Player</title>
<style>
  body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
  canvas { display: block; }
  .info-panel {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 10px;
    border-radius: 5px;
    font-family: Arial, sans-serif;
    width: 250px;
  }
  .info-panel h3 {
    margin-top: 0;
    color: #007bff;
    border-bottom: 1px solid #007bff;
    padding-bottom: 5px;
  }
  .info-panel ul {
    list-style-type: none;
    padding: 0;
  }
  .info-panel li {
    margin-bottom: 5px;
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

<div class="info-panel">
  <h3>üèÄ Quick Play Setup</h3>
  <p>The **Player Model** and **Basketball** are now added to the scene, ready for coding movement and physics.</p>
  
  <strong>New Elements Added:</strong>
  <ul>
    <li>**Player Model:** Simple Capsule/Sphere.</li>
    <li>**Basketball:** Orange Sphere, attached to player.</li>
  </ul>
  
  <p>Hoop Specs are confirmed.</p>
</div>

<script>
  // --- Setup Scene ---
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0xf0f0f0); 
  document.body.appendChild(renderer.domElement);

  // Add orbit controls for user interaction
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  // Camera Position: Set to view the player and hoop
  camera.position.set(5, 5, 20); 
  controls.target.set(0, 5, 0); // Focus camera on the player's general area
  controls.update();

  // Add lighting
  const ambientLight = new THREE.AmbientLight(0x404040, 5);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
  directionalLight.position.set(5, 10, 7);
  scene.add(directionalLight);
  
  // --- Constants ---
  const SCALE = 1/10; // 1 unit = 10 inches 
  const RIM_Y_POSITION = 120 * SCALE; // 12 units (10 feet)

  // --- Hoop and Court Geometry (Kept from V3) ---
  
  // Backboard
  const backboardWidth = 72 * SCALE;
  const backboardHeight = 42 * SCALE;
  const backboardDepth = 2 * SCALE;
  const backboardY = RIM_Y_POSITION + backboardHeight / 2 - 6 * SCALE; 
  
  const backboardGeometry = new THREE.BoxGeometry(backboardWidth, backboardHeight, backboardDepth);
  const backboardMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, shininess: 150 });
  const backboard = new THREE.Mesh(backboardGeometry, backboardMaterial);
  backboard.position.set(0, backboardY, 0);
  scene.add(backboard);

  // Rim (and related support/net)
  const rimOuterRadius = 18 * SCALE / 2 + 1 * SCALE / 2;
  const rimTubeRadius = 1 * SCALE / 2; 

  const rimGeometry = new THREE.TorusGeometry(rimOuterRadius, rimTubeRadius, 16, 100);
  const rimMaterial = new THREE.MeshPhongMaterial({ color: 0xff4500 });
  const rim = new THREE.Mesh(rimGeometry, rimMaterial);
  const rimZOffset = backboardDepth / 2 + rimOuterRadius - 0.5 * SCALE;
  rim.position.set(0, RIM_Y_POSITION, rimZOffset);
  rim.rotation.x = Math.PI / 2;
  scene.add(rim);

  // Pole/Stand
  const poleHeight = RIM_Y_POSITION; 
  const poleRadius = 10 * SCALE;
  const poleGeometry = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight, 32);
  const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
  const pole = new THREE.Mesh(poleGeometry, poleMaterial);
  pole.position.set(0, poleHeight / 2, -10 * SCALE);
  scene.add(pole);

  // Court Floor
  const courtWidth = 30;
  const courtDepth = 40;
  const floorGeometry = new THREE.PlaneGeometry(courtWidth, courtDepth);
  const floorMaterial = new THREE.MeshPhongMaterial({ color: 0xcc9966, side: THREE.DoubleSide });
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = Math.PI / 2; 
  floor.position.y = 0;
  floor.position.z = 10;
  scene.add(floor);


  // --- NEW: Player Model ---
  const playerGroup = new THREE.Group();
  const playerX = 0;
  const playerZ = floor.position.z + courtDepth / 2 - 5; // Position player a few units back from the hoop

  // 1. Body (Capsule)
  const bodyHeight = 1.5;
  const bodyRadius = 0.3;
  const bodyGeometry = new THREE.CapsuleGeometry(bodyRadius, bodyHeight, 10, 20);
  const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x007bff }); // Blue Jersey
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.position.y = bodyHeight / 2 + bodyRadius; // Base rests on the floor
  playerGroup.add(body);

  // 2. Head (Sphere)
  const headRadius = 0.25;
  const headGeometry = new THREE.SphereGeometry(headRadius, 32, 32);
  const headMaterial = new THREE.MeshPhongMaterial({ color: 0xf0d9b5 }); // Skin tone
  const head = new THREE.Mesh(headGeometry, headMaterial);
  head.position.y = body.position.y + bodyHeight / 2 + headRadius - 0.1; // Sits on top of the body
  playerGroup.add(head);

  // Position the entire player group
  playerGroup.position.set(playerX, 0, playerZ);
  scene.add(playerGroup);


  // --- NEW: Basketball Model ---
  const basketballRadius = 0.2; // ~8 inches (standard size 7)
  const basketballGeometry = new THREE.SphereGeometry(basketballRadius, 32, 32);
  const basketballMaterial = new THREE.MeshPhongMaterial({ color: 0xff8c00 }); // Orange
  const basketball = new THREE.Mesh(basketballGeometry, basketballMaterial);

  // Position the ball in the player's hands (a bit above the waist)
  const ballY = body.position.y + bodyRadius * 2; 
  basketball.position.set(playerX, ballY, playerZ + bodyRadius); 
  
  // Attach the ball to the player's group so it moves with the player
  playerGroup.add(basketball); 
  
  // Set the ball's position relative to the playerGroup's center (0, 0, 0)
  basketball.position.set(0, ballY, bodyRadius); 


  // --- Render Loop (Rest of the scene elements are here for completeness) ---
  
  // Backboard details (padding, target box)
  const paddingHeight = 6 * SCALE;
  const paddingDepth = 4 * SCALE;
  const paddingGeometry = new THREE.BoxGeometry(backboardWidth, paddingHeight, paddingDepth);
  const paddingMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
  const padding = new THREE.Mesh(paddingGeometry, paddingMaterial);
  padding.position.set(0, backboardY - backboardHeight / 2 + paddingHeight / 2, backboardDepth / 2 + paddingDepth / 2 - 0.05);
  scene.add(padding);

  const targetBoxWidth = 24 * SCALE;
  const targetBoxHeight = 18 * SCALE;
  const targetBoxY = backboardY - (backboardHeight / 2) + (targetBoxHeight / 2) + paddingHeight;
  
  const targetBoxShape = new THREE.Shape();
  targetBoxShape.moveTo(-targetBoxWidth / 2, -targetBoxHeight / 2);
  targetBoxShape.lineTo(targetBoxWidth / 2, -targetBoxHeight / 2);
  targetBoxShape.lineTo(targetBoxWidth / 2, targetBoxHeight / 2);
  targetBoxShape.lineTo(-targetBoxWidth / 2, targetBoxHeight / 2);
  targetBoxShape.lineTo(-targetBoxWidth / 2, -targetBoxHeight / 2);

  const targetBoxGeometry = new THREE.ShapeGeometry(targetBoxShape);
  const targetBoxMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
  const targetBoxLine = new THREE.LineSegments(new THREE.EdgesGeometry(targetBoxGeometry), targetBoxMaterial);
  targetBoxLine.position.set(0, targetBoxY, backboardDepth / 2 + 0.01);
  scene.add(targetBoxLine);
  
  // Net
  const netHeight = 15 * SCALE;
  const netTopRadius = rimOuterRadius - rimTubeRadius * 2;
  const netBottomRadius = 5 * SCALE;
  
  const netGeometry = new THREE.CylinderGeometry(netTopRadius, netBottomRadius, netHeight, 32, 1, true);
  const netMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc, wireframe: true, transparent: true, opacity: 0.5 }); 
  const net = new THREE.Mesh(netGeometry, netMaterial);
  net.position.set(rim.position.x, RIM_Y_POSITION - netHeight / 2, rim.position.z);
  scene.add(net);
  
  // Support Structure
  const supportLength = rim.position.z - backboardDepth / 2 - 0.5 * SCALE; 
  const supportGeometry = new THREE.BoxGeometry(5 * SCALE, 5 * SCALE, supportLength);
  const supportMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
  const support = new THREE.Mesh(supportGeometry, supportMaterial);
  support.position.set(0, RIM_Y_POSITION, backboardDepth / 2 + supportLength / 2);
  scene.add(support);
  
  
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  
  animate();

  // Handle window resizing
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }, false);
</script>

</body>
</html>
