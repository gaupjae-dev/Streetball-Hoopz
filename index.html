<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basketball Game 3D Holding</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- THREE.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- CANNON.js Physics library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            height: 100vh;
            background-color: #e5e7eb; 
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #scene-container {
            width: 100%;
            height: 100%;
        }
        #controls-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    <div id="controls-info">
        Movement: **W A S D** | Look: **Mouse Drag** | Shoot: **SPACEBAR**
    </div>

    <script>
        // --- Game Constants ---
        const HOOP_HEIGHT = 3.05; 
        const RIM_RADIUS = 0.457 / 2; 
        const RIM_TUBE_RADIUS = 0.03;
        const RIM_CENTER_Y = HOOP_HEIGHT; // Fix for ReferenceError
        const BACKBOARD_DISTANCE = 1.0; 
        const RIM_CENTER_Z_OFFSET = -BACKBOARD_DISTANCE + RIM_RADIUS; 

        const COURT_WIDTH = 15;
        const COURT_Z_LENGTH = 14;
        const BALL_RADIUS = 0.24;
        const ORIGINAL_BALL_MASS = 0.6;
        
        // Offset for holding the ball (relative to camera: right, slightly down, slightly forward)
        const BALL_HOLD_OFFSET = new THREE.Vector3(BALL_RADIUS * 1.5, -0.4, -BALL_RADIUS * 2.5); 
        const RETRIEVE_DISTANCE_SQ = 1.5 * 1.5; // Distance to automatically retrieve the ball

        // Player/Movement Globals
        let scene, camera, renderer;
        let player; 
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const playerHeight = 1.8;
        const playerSpeed = 0.15; 
        const rotationSpeed = 0.005;

        // Physics Globals
        let world;
        let ballBody, ballMesh;
        let isBallHeld = true; // State: Is the ball in the player's hands?
        const timeStep = 1 / 60;
        
        window.onload = function () {
            init();
            setupPlayerControls();
            animate();
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- INIT AND MODELING FUNCTIONS ---
        function init() {
            const container = document.getElementById('scene-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // --- THREE.js Setup ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xcccccc); 

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            
            // Player Group (Holds camera for FPV)
            player = new THREE.Group();
            player.position.set(0, playerHeight, COURT_Z_LENGTH / 2); // Start near center court
            player.add(camera);
            scene.add(player);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 3.5);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;

            
            // --- CANNON.js Setup ---
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); 
            world.broadphase = new CANNON.NaiveBroadphase();

            // Create materials for physics interactions
            const courtMaterial = new CANNON.Material("courtMaterial");
            const ballMaterial = new CANNON.Material("ballMaterial");
            const hoopMaterial = new CANNON.Material("hoopMaterial");

            const ballCourtContact = new CANNON.ContactMaterial(ballMaterial, courtMaterial, {
                friction: 0.5,
                restitution: 0.7 
            });
            const ballHoopContact = new CANNON.ContactMaterial(ballMaterial, hoopMaterial, {
                friction: 0.1,
                restitution: 0.3 
            });

            world.addContactMaterial(ballCourtContact);
            world.addContactMaterial(ballHoopContact);

            // Create models and physics bodies
            createCourt(scene);
            const hoopGroup = new THREE.Group();
            createHoop(hoopGroup);
            hoopGroup.position.set(0, 0, -COURT_Z_LENGTH); 
            scene.add(hoopGroup);

            createPhysicsWorld(courtMaterial, hoopMaterial);
            createBallModel(ballMaterial);
            holdBall(); // Start with the ball held
        }

        // Helper function for creating thick, 3D court lines
        function createLinePlane(width, length, color = 0xffffff, xPos = 0, zPos = 0, yRotation = 0) {
            const geometry = new THREE.PlaneGeometry(width, length);
            const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2; 
            mesh.rotation.z = yRotation;    
            mesh.position.set(xPos, 0.015, zPos); 
            return mesh;
        }

        function createCourt(courtGroup) {
            // Main court surface (Hardwood color)
            const courtGeometry = new THREE.PlaneGeometry(COURT_WIDTH * 2, COURT_Z_LENGTH * 2);
            const courtMaterial = new THREE.MeshLambertMaterial({ color: 0xc46210 }); 
            const court = new THREE.Mesh(courtGeometry, courtMaterial);
            court.rotation.x = -Math.PI / 2;
            court.position.y = -0.1;
            court.receiveShadow = true; 
            courtGroup.add(court);

            // Court markings (omitting line generation for brevity but keeping necessary surface for lines)
            const lineThickness = 0.05;
            const keyColor = 0x8a2be2; 
            const freeThrowLineDistance = 5.8;

            // Half-court line 
            courtGroup.add(createLinePlane(COURT_WIDTH * 2, lineThickness, 0xffffff, 0, 0, 0));

            // Key/Paint Area (Filled)
            const keyGeometry = new THREE.PlaneGeometry(4.9, freeThrowLineDistance);
            const keyMaterial = new THREE.MeshBasicMaterial({ color: keyColor });
            const key = new THREE.Mesh(keyGeometry, keyMaterial);
            key.rotation.x = -Math.PI / 2;
            key.position.y = 0.005;
            key.position.z = -COURT_Z_LENGTH + (freeThrowLineDistance / 2);
            courtGroup.add(key);
        }

        function createHoop(hoopGroup) {
            const BACKBOARD_WIDTH = 1.83, BACKBOARD_HEIGHT = 1.07, BACKBOARD_THICKNESS = 0.03;
            const NET_LENGTH = 0.45;
            
            // Backboard 
            const backboardGeometry = new THREE.BoxGeometry(BACKBOARD_WIDTH, BACKBOARD_HEIGHT, BACKBOARD_THICKNESS);
            const backboardMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, transparent: true, opacity: 0.8, shininess: 150});
            const backboard = new THREE.Mesh(backboardGeometry, backboardMaterial);
            backboard.position.set(0, RIM_CENTER_Y + (BACKBOARD_HEIGHT / 2) - 0.3, RIM_CENTER_Z_OFFSET);
            backboard.castShadow = true; 
            hoopGroup.add(backboard);

            // Rim 
            const rimGeometry = new THREE.TorusGeometry(RIM_RADIUS, RIM_TUBE_RADIUS, 12, 60);
            const rimMaterial = new THREE.MeshPhongMaterial({ color: 0xff4500, shininess: 80 });
            const rim = new THREE.Mesh(rimGeometry, rimMaterial);
            rim.rotation.x = Math.PI / 2;
            rim.position.set(0, RIM_CENTER_Y, RIM_CENTER_Z_OFFSET + RIM_RADIUS); 
            rim.castShadow = true; 
            hoopGroup.add(rim);

            // Net (visual only, physics done via rim/backboard bodies)
            const netGeometry = new THREE.CylinderGeometry(RIM_RADIUS, RIM_RADIUS * 0.5, NET_LENGTH, 60, 1, true); 
            const netMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, transparent: true, opacity: 0.8, wireframe: true, side: THREE.DoubleSide});
            const net = new THREE.Mesh(netGeometry, netMaterial);
            net.position.set(rim.position.x, rim.position.y - NET_LENGTH / 2, rim.position.z);
            hoopGroup.add(net);
        }

        // --- PHYSICS BODY CREATION ---
        function createPhysicsWorld(courtMat, hoopMat) {
            // 1. Court Ground Body (Static)
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0, shape: groundShape, material: courtMat });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); 
            groundBody.position.y = -0.1; // Match THREE.js floor position
            world.addBody(groundBody);
            
            // 2. Backboard Body (Static)
            const BACKBOARD_WIDTH = 1.83, BACKBOARD_HEIGHT = 1.07, BACKBOARD_THICKNESS = 0.03;
            const backboardShape = new CANNON.Box(new CANNON.Vec3(BACKBOARD_WIDTH / 2, BACKBOARD_HEIGHT / 2, BACKBOARD_THICKNESS / 2));
            const backboardBody = new CANNON.Body({ mass: 0, shape: backboardShape, material: hoopMat });
            backboardBody.position.set(0, HOOP_HEIGHT + (BACKBOARD_HEIGHT / 2) - 0.3, -COURT_Z_LENGTH + RIM_CENTER_Z_OFFSET);
            world.addBody(backboardBody);

            // 3. Rim Collision (Static)
            const RIM_THICKNESS_COLLISION = 0.05;
            const rimShape = new CANNON.Cylinder(RIM_RADIUS, RIM_RADIUS, RIM_THICKNESS_COLLISION, 20);
            const rimBody = new CANNON.Body({ mass: 0, shape: rimShape, material: hoopMat });
            
            rimBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            rimBody.position.set(0, RIM_CENTER_Y, -COURT_Z_LENGTH + RIM_CENTER_Z_OFFSET + RIM_RADIUS);
            world.addBody(rimBody);
        }

        // Dynamic basketball model
        function createBallModel(ballMat) {
            // THREE.js Mesh
            const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
            const ballMaterial = new THREE.MeshLambertMaterial({ color: 0xff8c00 });
            ballMesh = new THREE.Mesh(ballGeometry, ballMaterial);
            ballMesh.castShadow = true;
            scene.add(ballMesh);
            
            // CANNON.js Body: Start with mass 0 (held)
            const ballShape = new CANNON.Sphere(BALL_RADIUS);
            ballBody = new CANNON.Body({ mass: 0, shape: ballShape, material: ballMat });
            world.addBody(ballBody);
        }

        // Initiates the "holding" state (player retrieves the ball)
        function holdBall() {
            // Stop any current motion
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);
            ballBody.mass = 0; // Disable physics interaction (cinematic/static)
            ballBody.updateMassProperties();
            isBallHeld = true;
        }

        function shootBall() {
            if (!isBallHeld) return;
            
            isBallHeld = false;
            ballBody.mass = ORIGINAL_BALL_MASS; // Re-enable physics
            ballBody.updateMassProperties();

            // Get the camera's world direction (where the player is looking)
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);

            // Get the ball's current held position (synced in updatePlayerMovement)
            const ballPos = ballMesh.position;
            ballBody.position.copy(ballPos); // Sync CANNON body to THREE mesh position before impulse

            // Apply a launch speed/force 
            const launchSpeed = 15; // Increased launch speed 
            const impulse = new CANNON.Vec3(
                direction.x * launchSpeed * ORIGINAL_BALL_MASS,
                direction.y * launchSpeed * ORIGINAL_BALL_MASS * 1.5, // Added vertical boost for arc
                direction.z * launchSpeed * ORIGINAL_BALL_MASS
            );
            
            ballBody.applyImpulse(impulse, ballBody.position);
        }

        // --- INPUT AND MOVEMENT LOGIC ---
        function setupPlayerControls() {
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': 
                        shootBall();
                        break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            });
            
            // Simple mouse drag to rotate the player (and camera)
            let isDragging = false;
            let previousMouseX = 0;

            renderer.domElement.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMouseX = event.clientX;
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isDragging) return;

                const deltaX = event.clientX - previousMouseX;
                // Rotate the player group around the Y-axis
                player.rotation.y -= deltaX * rotationSpeed; 
                previousMouseX = event.clientX;
            });
        }

        function updatePlayerMovement() {
            const tempVector = new THREE.Vector3(0, 0, 0);
            
            // Get the current forward direction of the player
            const forward = new THREE.Vector3();
            player.getWorldDirection(forward); 
            forward.y = 0; // Only horizontal movement
            forward.normalize();

            // Get the right vector (strafing direction)
            const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), forward).normalize(); 

            // Calculate movement vector
            if (moveForward) tempVector.add(forward);
            if (moveBackward) tempVector.sub(forward);
            if (moveLeft) tempVector.sub(right); // Strafing
            if (moveRight) tempVector.add(right); // Strafing

            if (tempVector.lengthSq() > 0) {
                tempVector.normalize();
                player.position.add(tempVector.multiplyScalar(playerSpeed));
            }
            
            // Boundary Check
            player.position.x = Math.max(-COURT_WIDTH + 0.5, Math.min(COURT_WIDTH - 0.5, player.position.x));
            player.position.z = Math.max(-COURT_Z_LENGTH + 0.5, Math.min(COURT_Z_LENGTH * 1.5, player.position.z));
            player.position.y = playerHeight; 
            
            // Holding Logic: If the ball is held, fix its position relative to the camera
            if (isBallHeld) {
                const tempPos = BALL_HOLD_OFFSET.clone();
                
                // Transform the local offset (relative to camera) into world coordinates
                camera.localToWorld(tempPos); 

                // Sync THREE mesh and CANNON body position
                ballMesh.position.copy(tempPos);
                ballBody.position.copy(tempPos);
                
                // Ensure the ball has no velocity/spin while being held
                ballBody.velocity.set(0, 0, 0);
                ballBody.angularVelocity.set(0, 0, 0);
            } else {
                // Retrieval Logic: If not held, check if player is close enough to retrieve it
                const playerPos2D = new THREE.Vector3(player.position.x, 0, player.position.z);
                const ballPos2D = new THREE.Vector3(ballMesh.position.x, 0, ballMesh.position.z);
                const playerToBallDistSq = playerPos2D.distanceToSquared(ballPos2D);
                
                // Check distance and if the ball is near the ground and slow moving
                if (playerToBallDistSq < RETRIEVE_DISTANCE_SQ && ballBody.position.y < 0.5) {
                    const speed = ballBody.velocity.length();
                    if (speed < 1.5) { // Slow enough to pick up
                        holdBall();
                    }
                }
            }
        }

        function updatePhysics() {
            // Step the physics world
            world.step(timeStep);

            // Copy position and rotation from CANNON to THREE only if the ball is NOT held
            if (!isBallHeld) {
                ballMesh.position.copy(ballBody.position);
                ballMesh.quaternion.copy(ballBody.quaternion);
            }

            // Ball reset logic (if it falls off the court entirely)
            if (ballBody.position.y < -5) {
                console.log("Ball out of bounds. Retrieving.");
                // If the ball falls too far, put it back in the player's hands
                holdBall();
            }
        }


        function onWindowResize() {
            const container = document.getElementById('scene-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePlayerMovement();
            updatePhysics();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
