<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basketball Game FPV Environment</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- THREE.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            height: 100vh;
            background-color: #e5e7eb; /* Light gray/gym color for environment */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #scene-container {
            width: 100%;
            height: 100%;
        }
        #controls-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    <div id="controls-info">
        Movement: **W A S D** | Look: **Mouse** (Click and drag to orbit camera)
    </div>

    <script>
        // --- Court and Hoop Constants ---
        const HOOP_HEIGHT = 3.05; 
        const RIM_RADIUS = 0.457 / 2; 
        const RIM_TUBE_RADIUS = 0.03;
        const RIM_CENTER_Y = HOOP_HEIGHT;
        const RIM_CENTER_Z_OFFSET = -1.0 - 0.15;
        
        // Court Constants (Half Court)
        const COURT_WIDTH = 15;
        const COURT_Z_LENGTH = 14;
        const THREE_POINT_LINE_RADIUS = 7.24;
        const THREE_POINT_LINE_STRAIGHT_DISTANCE = 6.7; 
        const PAINT_WIDTH = 4.9; 
        const FREE_THROW_LINE_DISTANCE = 5.8; 
        const LINE_THICKNESS = 0.05; 

        // Player/Movement Globals
        let scene, camera, renderer;
        let player; // Player group for FPV position
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const playerHeight = 1.8;
        const playerSpeed = 0.1;
        const rotationSpeed = 0.005;

        window.onload = function () {
            init();
            setupPlayerControls();
            animate();
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- INIT AND MODELING FUNCTIONS ---
        function init() {
            const container = document.getElementById('scene-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xcccccc); // Lighter background color

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            
            // Create the Player Group and attach the camera
            player = new THREE.Group();
            player.position.set(0, playerHeight, COURT_Z_LENGTH / 2); // Start near center court
            player.add(camera);
            scene.add(player);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            
            // ENABLE SHADOWS
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 

            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 3.5);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;

            
            // Create the court and hoop models, they are now added directly to the scene
            const courtGroup = new THREE.Group();
            const hoopGroup = new THREE.Group();

            createCourt(courtGroup);
            createHoop(hoopGroup);
            createBallModel(player);
            
            // Position the hoop at the far end of the half court
            hoopGroup.position.set(0, 0, -COURT_Z_LENGTH); 
            
            scene.add(courtGroup);
            scene.add(hoopGroup);
        }

        // Helper function for creating thick, 3D court lines
        function createLinePlane(width, length, color = 0xffffff, xPos = 0, zPos = 0, yRotation = 0) {
            const geometry = new THREE.PlaneGeometry(width, length);
            const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.rotation.x = -Math.PI / 2; 
            mesh.rotation.z = yRotation;    
            mesh.position.set(xPos, 0.015, zPos); 
            
            return mesh;
        }

        function createCourt(courtGroup) {
            // Main court surface (Hardwood color)
            const courtGeometry = new THREE.PlaneGeometry(COURT_WIDTH * 2, COURT_Z_LENGTH * 2);
            const courtMaterial = new THREE.MeshLambertMaterial({ color: 0xc46210 }); 
            const court = new THREE.Mesh(courtGeometry, courtMaterial);
            court.rotation.x = -Math.PI / 2;
            court.position.y = -0.1;
            court.receiveShadow = true; 
            courtGroup.add(court);

            const white = 0xffffff;
            const keyColor = 0x8a2be2; 
            
            // --- COURT MARKINGS ---
            
            // Out-of-bounds / Baseline 
            courtGroup.add(createLinePlane(COURT_WIDTH * 2, LINE_THICKNESS, white, 0, -COURT_Z_LENGTH, 0));

            // Out-of-bounds (sidelines)
            courtGroup.add(createLinePlane(LINE_THICKNESS, COURT_Z_LENGTH * 2, white, -COURT_WIDTH, 0, 0));
            courtGroup.add(createLinePlane(LINE_THICKNESS, COURT_Z_LENGTH * 2, white, COURT_WIDTH, 0, 0));
            
            // Mid Court Line
            courtGroup.add(createLinePlane(COURT_WIDTH * 2, LINE_THICKNESS, white, 0, 0, 0));
            
            // The Key / Paint Area (Filled)
            const keyGeometry = new THREE.PlaneGeometry(PAINT_WIDTH, FREE_THROW_LINE_DISTANCE);
            const keyMaterial = new THREE.MeshBasicMaterial({ color: keyColor });
            const key = new THREE.Mesh(keyGeometry, keyMaterial);
            key.rotation.x = -Math.PI / 2;
            key.position.y = 0.005;
            key.position.z = -COURT_Z_LENGTH + (FREE_THROW_LINE_DISTANCE / 2);
            courtGroup.add(key);

            // Free Throw Line 
            courtGroup.add(createLinePlane(PAINT_WIDTH, LINE_THICKNESS, white, 0, -COURT_Z_LENGTH + FREE_THROW_LINE_DISTANCE, 0));

            // Free Throw Arc (Half circle)
            const ftArcGeometry = new THREE.RingGeometry(1.8, 1.8 + LINE_THICKNESS, 32, 1, 0, Math.PI);
            const ftArcMaterial = new THREE.MeshBasicMaterial({ color: white, side: THREE.DoubleSide });
            const ftArc = new THREE.Mesh(ftArcGeometry, ftArcMaterial);
            ftArc.rotation.x = -Math.PI / 2;
            ftArc.position.y = 0.015;
            ftArc.position.z = -COURT_Z_LENGTH + FREE_THROW_LINE_DISTANCE;
            courtGroup.add(ftArc);

            // Three Point Line Arc
            const threePtRadius = THREE_POINT_LINE_RADIUS;
            const arcStartAngle = Math.asin(THREE_POINT_LINE_STRAIGHT_DISTANCE / threePtRadius);
            const arcEndAngle = Math.PI - arcStartAngle;
            const threeArcGeometry = new THREE.RingGeometry(threePtRadius, threePtRadius + LINE_THICKNESS, 64, 1, arcStartAngle, arcEndAngle - arcStartAngle);
            const threeArcMaterial = new THREE.MeshBasicMaterial({ color: white, side: THREE.DoubleSide });
            const threeArc = new THREE.Mesh(threeArcGeometry, threeArcMaterial);
            threeArc.rotation.x = -Math.PI / 2;
            threeArc.position.y = 0.015;
            threeArc.position.z = -COURT_Z_LENGTH; 
            courtGroup.add(threeArc);

            // Three Point Straight Lines
            const straightLineLength = THREE_POINT_LINE_STRAIGHT_DISTANCE;
            const straightLineZ = -COURT_Z_LENGTH + (straightLineLength / 2);

            courtGroup.add(createLinePlane(LINE_THICKNESS, straightLineLength, white, -threePtRadius, straightLineZ, 0));
            courtGroup.add(createLinePlane(LINE_THICKNESS, straightLineLength, white, threePtRadius, straightLineZ, 0));
        }

        function createHoop(hoopGroup) {
            const BACKBOARD_WIDTH = 1.83, BACKBOARD_HEIGHT = 1.07, BACKBOARD_THICKNESS = 0.03;
            const PADDING_HEIGHT = 0.2, NET_LENGTH = 0.45;
            
            // Backboard 
            const backboardGeometry = new THREE.BoxGeometry(BACKBOARD_WIDTH, BACKBOARD_HEIGHT, BACKBOARD_THICKNESS);
            const backboardMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, transparent: true, opacity: 0.8, shininess: 150});
            const backboard = new THREE.Mesh(backboardGeometry, backboardMaterial);
            backboard.position.set(0, RIM_CENTER_Y + (BACKBOARD_HEIGHT / 2) - 0.3, RIM_CENTER_Z_OFFSET);
            backboard.castShadow = true; 
            hoopGroup.add(backboard);

            // Backboard Padding 
            const paddingGeometry = new THREE.BoxGeometry(BACKBOARD_WIDTH, PADDING_HEIGHT, BACKBOARD_THICKNESS * 2);
            const paddingMaterial = new THREE.MeshLambertMaterial({ color: 0xcc0000 });
            const padding = new THREE.Mesh(paddingGeometry, paddingMaterial);
            padding.position.set(backboard.position.x, backboard.position.y - (BACKBOARD_HEIGHT / 2) + (PADDING_HEIGHT / 2), backboard.position.z);
            padding.castShadow = true; 
            hoopGroup.add(padding);

            // Rim 
            const rimGeometry = new THREE.TorusGeometry(RIM_RADIUS, RIM_TUBE_RADIUS, 12, 60);
            const rimMaterial = new THREE.MeshPhongMaterial({ color: 0xff4500, shininess: 80 });
            const rim = new THREE.Mesh(rimGeometry, rimMaterial);
            rim.rotation.x = Math.PI / 2;
            rim.position.set(0, RIM_CENTER_Y, RIM_CENTER_Z_OFFSET + 1.0); 
            rim.castShadow = true; 
            hoopGroup.add(rim);

            // Net
            const netGeometry = new THREE.CylinderGeometry(RIM_RADIUS, RIM_RADIUS * 0.5, NET_LENGTH, 60, 1, true); 
            const netMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, transparent: true, opacity: 0.8, wireframe: true, side: THREE.DoubleSide});
            const net = new THREE.Mesh(netGeometry, netMaterial);
            net.position.set(rim.position.x, rim.position.y - NET_LENGTH / 2, rim.position.z);
            hoopGroup.add(net);

            // Pole
            const poleGeometry = new THREE.CylinderGeometry(0.15, 0.15, 6, 32);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x475569 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(0, 3, rim.position.z - 2.5);
            pole.castShadow = true; 
            hoopGroup.add(pole);
        }
        
        // Simple basketball model, attached to the player's view
        function createBallModel(parent) {
            const ballRadius = 0.24;
            const ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const ballMaterial = new THREE.MeshLambertMaterial({ color: 0xff8c00 });
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            
            // Position the ball in front of the camera, slightly down and to the right
            ball.position.set(0.5, -0.4, -1);
            parent.add(ball);
        }


        // --- INPUT AND MOVEMENT LOGIC ---
        function setupPlayerControls() {
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            });
            
            // Simple mouse drag to rotate the player (and camera)
            let isDragging = false;
            let previousMouseX = 0;

            renderer.domElement.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMouseX = event.clientX;
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isDragging) return;

                const deltaX = event.clientX - previousMouseX;
                // Rotate the player group around its Y-axis (vertical)
                player.rotation.y -= deltaX * rotationSpeed; 
                previousMouseX = event.clientX;
            });
        }

        function updatePlayerMovement() {
            const velocity = new THREE.Vector3(0, 0, 0);
            
            // Get the camera's current forward and side directions
            const direction = new THREE.Vector3();
            player.getWorldDirection(direction); // Get forward direction vector
            const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), direction).normalize(); // Get right vector

            if (moveForward) velocity.add(direction);
            if (moveBackward) velocity.sub(direction);
            if (moveLeft) velocity.sub(right);
            if (moveRight) velocity.add(right);

            // Ignore the Y component to keep movement strictly on the floor plane
            velocity.y = 0;
            velocity.normalize();
            
            // Apply movement
            player.position.add(velocity.multiplyScalar(playerSpeed));
            
            // Simple boundary check (optional but helpful)
            player.position.x = Math.max(-COURT_WIDTH + 0.5, Math.min(COURT_WIDTH - 0.5, player.position.x));
            player.position.z = Math.max(-COURT_Z_LENGTH + 0.5, Math.min(COURT_Z_LENGTH * 1.5, player.position.z));
            player.position.y = playerHeight; // Always keep player at correct height
        }


        function onWindowResize() {
            const container = document.getElementById('scene-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePlayerMovement();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
