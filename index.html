<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE G.O.A.T. PROJECT</title>

    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="main-menu-container" id="main-menu-container">
        
        <div class="main-menu-top">
            
            <h1 class="main-title">THE G.O.A.T. PROJECT</h1>
            
            <div class="main-modes-wrapper">
                <button class="menu-button" onclick="quickPlay()">QUICK PLAY (3D)</button>
                <button class="menu-button" onclick="loadMissions()">MISSIONS</button>
                <button class="menu-button" onclick="loadMyHub()">MY HUB</button>
            </div>
        </div>

        <div id="user-info" class="absolute top-2 right-4 text-xs sm:text-sm text-neon-blue text-center hidden"></div>

        <div class="main-menu-bottom">
            <button class="menu-button" onclick="loadOptions()">OPTIONS</button>
            <button class="menu-button" onclick="quitGame()">QUIT</button>
        </div>
        
    </div>

    <div id="quickplay-container" class="quickplay-game-mode hidden">
        <div id="scene-container"></div>
        
        <div id="camera-toggle" onclick="switchCameraView()">
            <svg id="camera-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
        </div>

        <div id="shot-meter-container" class="hidden">
            <div id="shot-meter-sweet-spot"></div>
            <div id="shot-meter-fill"></div>
        </div>
        
        <div id="controls-info">
            Movement: **W A S D** | Look: **Mouse Drag** | Shoot: **SPACEBAR** | Pickup: **Walk over the ball**
        </div>
        
        <div id="score-display">
            Score: <span id="score-value">0</span>
        </div>
        
        <button id="quickplay-exit-button" class="menu-button absolute top-4 left-4" onclick="exitQuickPlay()">EXIT</button>
    </div>

    <div id="missions-log-container" class="missions-log-container hidden">
        <h2>MISSIONS LOG</h2>
        <div id="mission-list">
            <button class="mission-item" onclick="loadMission(1)">Mission 1: Training Drill - Free Throws</button>
            <button class="mission-item" onclick="loadMission(2)">Mission 2: Contract Signing - Agent's Offer</button>
            <button class="mission-item" disabled>Mission 3: Lock-in (LOCKED)</button>
        </div>
        <button class="menu-button" onclick="loadMainMenu()">BACK</button>
    </div>

    <div id="my-player-container" class="my-player-container hidden">
        <h2>MY HUB</h2>
        <p>Name: <span id="player-name">Rookie</span></p>
        <p>Overall Rating: <span id="player-ovr">50</span></p>
        <p>XP Level: <span id="player-level">1</span></p>
        <p>XP Progress:</p>
        <div class="progress-bar-container"><div id="xp-progress-bar" class="progress-bar"></div></div>
        <button class="menu-button" onclick="loadMainMenu()">BACK</button>
    </div>

    <div id="options-container" class="options-container hidden">
        <h2>OPTIONS</h2>
        <p>Volume: 50%</p>
        <p>Resolution: 1920x1080</p>
        <p>Graphics: High</p>
        <button class="menu-button" onclick="loadMainMenu()">BACK</button>
    </div>

    <div id="quit-container" class="quit-container hidden">
        <h2>QUIT GAME</h2>
        <p>Are you sure you want to quit?</p>
        <button class="menu-button" onclick="confirmQuit()">YES, QUIT</button>
        <button class="menu-button" onclick="loadMainMenu()">NO, BACK</button>
    </div>
    
    <div id="mission-screen" class="mission-screen hidden">
        <h2 id="mission-title">Mission Title</h2>
        <p id="mission-description">Description goes here.</p>
        <div id="mission-content" class="mission-content">
            </div>
        <div id="mission-feedback"></div>
        <button id="mission-back-button" class="menu-button" onclick="loadMissions()">BACK TO MISSIONS</button>
    </div>

    <script>
        // --- GAME STATE AND INITIAL SETUP ---
        let currentScreen = 'main-menu-container';
        let gameInitialized = false; // Tracks if the 3D scene has been set up
        let animFrame; // Global variable to hold the animation frame ID

        // Placeholder functions for sub-screen navigation (you likely have these already)
        function loadMainMenu() {
            hideAllScreens();
            document.getElementById('main-menu-container').classList.remove('hidden');
            currentScreen = 'main-menu-container';
        }
        function loadMissions() {
            hideAllScreens();
            document.getElementById('missions-log-container').classList.remove('hidden');
            currentScreen = 'missions-log-container';
        }
        function loadMyHub() {
            hideAllScreens();
            document.getElementById('my-player-container').classList.remove('hidden');
            currentScreen = 'my-player-container';
        }
        function loadOptions() {
            hideAllScreens();
            document.getElementById('options-container').classList.remove('hidden');
            currentScreen = 'options-container';
        }
        function quitGame() {
            hideAllScreens();
            document.getElementById('quit-container').classList.remove('hidden');
            currentScreen = 'quit-container';
        }
        function confirmQuit() {
            alert("Game closed. Thanks for playing!");
            window.close(); // Note: modern browsers often block script-initiated closing
        }
        function loadMission(id) {
            // Logic to load specific mission content
            hideAllScreens();
            document.getElementById('mission-screen').classList.remove('hidden');
            currentScreen = 'mission-screen';
            // Placeholder: you'll need a proper handler to load mission content here
            document.getElementById('mission-title').innerText = `MISSION ${id}`;
            document.getElementById('mission-description').innerText = `Starting Mission ${id} training...`;
            document.getElementById('mission-content').innerHTML = `Mission ${id} content goes here.`;
        }

        function hideAllScreens() {
            document.getElementById('main-menu-container').classList.add('hidden');
            document.getElementById('missions-log-container').classList.add('hidden');
            document.getElementById('my-player-container').classList.add('hidden');
            document.getElementById('options-container').classList.add('hidden');
            document.getElementById('quit-container').classList.add('hidden');
            document.getElementById('mission-screen').classList.add('hidden');
            document.getElementById('quickplay-container').classList.add('hidden');
        }

        // =========================================================================
        // QUICK PLAY MODE START/EXIT LOGIC
        // =========================================================================

        function quickPlay() {
             startQuickPlay();
        }

        window.startQuickPlay = function() {
            hideAllScreens();
            document.getElementById('quickplay-container').classList.remove('hidden');

            if (!gameInitialized) {
                init(); 
                setupPlayerControls(); 
                gameInitialized = true;
            }
            
            animate(); 
            window.addEventListener('resize', onWindowResize, false);
            // Setup the initial FPV camera icon (Pointer)
            document.getElementById('camera-icon').innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>';
        }
        
        window.exitQuickPlay = function() {
            // Stop the animation loop
            if (animFrame) {
                cancelAnimationFrame(animFrame);
            }
             
            // Clear movement keys (so player doesn't keep moving in the menu)
            moveForward = moveBackward = moveLeft = moveRight = false;
            isChargingShot = false;

            // Hide quick play and show main menu
            document.getElementById('quickplay-container').classList.add('hidden');
            loadMainMenu();

            // Reset score for next time
            score = 0;
            document.getElementById('score-value').innerText = score;
        }

        // =========================================================================
        // QUICK PLAY 3D GAME LOGIC (Copied from your provided code)
        // =========================================================================

        // --- Game Constants ---
        const HOOP_HEIGHT = 3.05; 
        const RIM_RADIUS = 0.457 / 2; // ~0.2285m
        const RIM_TUBE_RADIUS = 0.03;
        const RIM_CENTER_Y = HOOP_HEIGHT; 
        const BACKBOARD_DISTANCE = 1.0; 
        const RIM_CENTER_Z_OFFSET = -BACKBOARD_DISTANCE + RIM_RADIUS; 
        let RIM_CENTER_Z_WORLD; 

        const COURT_WIDTH = 15;
        const COURT_Z_LENGTH = 14;
        const BALL_RADIUS = 0.24;
        const ORIGINAL_BALL_MASS = 0.6;
        
        // Offset for holding the ball
        const BALL_HOLD_OFFSET = new THREE.Vector3(BALL_RADIUS * 1.5, -0.4, -BALL_RADIUS * 2.5); 
        const RETRIEVE_DISTANCE_SQ = 1.5 * 1.5; 

        // Player/Movement Globals
        let scene, camera, renderer;
        let player; 
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const playerHeight = 1.8;
        const playerSpeed = 0.15; 
        const rotationSpeed = 0.005;

        // Physics Globals
        let world;
        let ballBody, ballMesh;
        let isBallHeld = true; 
        let score = 0;
        let hasScoredThisShot = false;
        const timeStep = 1 / 60;
        
        // --- Shot Meter and Outcome Globals ---
        let isChargingShot = false;
        let shotChargeTime = 0;
        const MAX_SHOT_CHARGE_TIME = 1.0; // Max time in seconds for full power
        
        // Sweet spot window based on MAX_SHOT_CHARGE_TIME (40% to 70% of max charge)
        const SWEET_SPOT_MIN = MAX_SHOT_CHARGE_TIME * 0.4; 
        const SWEET_SPOT_MAX = MAX_SHOT_CHARGE_TIME * 0.7; 

        // --- Camera Globals ---
        let isThirdPerson = false;
        const TPV_CAMERA_OFFSET = new THREE.Vector3(0, 4, 6); 
        const TPV_LOOKAT_LOCAL = new THREE.Vector3(0, 1.8, -5); 
        
        // --- INIT AND MODELING FUNCTIONS ---
        function init() {
            const container = document.getElementById('scene-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            RIM_CENTER_Z_WORLD = -COURT_Z_LENGTH + RIM_CENTER_Z_OFFSET + RIM_RADIUS;

            // --- THREE.js Setup ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333); // Darker background for neon theme

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            
            player = new THREE.Group();
            player.position.set(0, playerHeight, COURT_Z_LENGTH / 2); 
            player.add(camera);
            scene.add(player);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            // Directional light for shadows
            const directionalLight = new THREE.DirectionalLight(0xffffff, 3.5);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;

            // --- CANNON.js Setup ---
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); 
            world.broadphase = new CANNON.NaiveBroadphase();

            const courtMaterial = new CANNON.Material("courtMaterial");
            const ballMaterial = new CANNON.Material("ballMaterial");
            const hoopMaterial = new CANNON.Material("hoopMaterial");

            const ballCourtContact = new CANNON.ContactMaterial(ballMaterial, courtMaterial, { friction: 0.5, restitution: 0.7 });
            const ballHoopContact = new CANNON.ContactMaterial(ballMaterial, hoopMaterial, { friction: 0.1, restitution: 0.3 });

            world.addContactMaterial(ballCourtContact);
            world.addContactMaterial(ballHoopContact);

            createCourt(scene);
            const hoopGroup = new THREE.Group();
            createHoop(hoopGroup);
            hoopGroup.position.set(0, 0, -COURT_Z_LENGTH); 
            scene.add(hoopGroup);

            createPhysicsWorld(courtMaterial, hoopMaterial);
            createBallModel(ballMaterial);
            holdBall();
        }

        // Helper function for creating court lines (Simplified)
        function createLinePlane(width, length, color = 0xffffff, xPos = 0, zPos = 0, yRotation = 0) {
            const geometry = new THREE.PlaneGeometry(width, length);
            const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2; 
            mesh.rotation.z = yRotation;  
            mesh.position.set(xPos, 0.015, zPos); 
            return mesh;
        }

        function createCourt(courtGroup) {
            const courtGeometry = new THREE.PlaneGeometry(COURT_WIDTH * 2, COURT_Z_LENGTH * 2);
            // Use a dark, non-reflective material for the court surface
            const courtMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 }); 
            const court = new THREE.Mesh(courtGeometry, courtMaterial);
            court.rotation.x = -Math.PI / 2;
            court.position.y = -0.1;
            court.receiveShadow = true; 
            courtGroup.add(court);

            const lineThickness = 0.05;
            const keyColor = 0x00c4ff; // Neon Blue for Key
            const freeThrowLineDistance = 5.8;

            // Boundary line (simplified)
            courtGroup.add(createLinePlane(COURT_WIDTH * 2, lineThickness, 0xffffff, 0, 0, 0));

            // Key/Paint Area
            const keyGeometry = new THREE.PlaneGeometry(4.9, freeThrowLineDistance);
            const keyMaterial = new THREE.MeshBasicMaterial({ color: keyColor, transparent: true, opacity: 0.2 }); // Semi-transparent neon blue
            const key = new THREE.Mesh(keyGeometry, keyMaterial);
            key.rotation.x = -Math.PI / 2;
            key.position.y = 0.005;
            key.position.z = -COURT_Z_LENGTH + (freeThrowLineDistance / 2);
            courtGroup.add(key);
        }

        function createHoop(hoopGroup) {
            const BACKBOARD_WIDTH = 1.83, BACKBOARD_HEIGHT = 1.07, BACKBOARD_THICKNESS = 0.03;
            const NET_LENGTH = 0.45;
            
            // Backboard - Neon Pink/White
            const backboardGeometry = new THREE.BoxGeometry(BACKBOARD_WIDTH, BACKBOARD_HEIGHT, BACKBOARD_THICKNESS);
            const backboardMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, transparent: true, opacity: 0.8, shininess: 150});
            const backboard = new THREE.Mesh(backboardGeometry, backboardMaterial);
            backboard.position.set(0, RIM_CENTER_Y + (BACKBOARD_HEIGHT / 2) - 0.3, RIM_CENTER_Z_OFFSET);
            backboard.castShadow = true; 
            hoopGroup.add(backboard);

            // Rim - Neon Pink
            const rimGeometry = new THREE.TorusGeometry(RIM_RADIUS, RIM_TUBE_RADIUS, 12, 60);
            const rimMaterial = new THREE.MeshPhongMaterial({ color: 0xff00ff, shininess: 80 }); // Neon Pink
            const rim = new THREE.Mesh(rimGeometry, rimMaterial);
            rim.rotation.x = Math.PI / 2;
            rim.position.set(0, RIM_CENTER_Y, RIM_CENTER_Z_OFFSET + RIM_RADIUS); 
            rim.castShadow = true; 
            hoopGroup.add(rim);
            
            // Net - Wireframe White
            const netGeometry = new THREE.CylinderGeometry(RIM_RADIUS, RIM_RADIUS * 0.5, NET_LENGTH, 60, 1, true); 
            const netMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, transparent: true, opacity: 0.8, wireframe: true, side: THREE.DoubleSide});
            const net = new THREE.Mesh(netGeometry, netMaterial);
            net.position.set(rim.position.x, rim.position.y - NET_LENGTH / 2, rim.position.z);
            hoopGroup.add(net);
        }

        function createPhysicsWorld(courtMat, hoopMat) {
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0, shape: groundShape, material: courtMat });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); 
            groundBody.position.y = -0.1; 
            world.addBody(groundBody);
            
            const BACKBOARD_WIDTH = 1.83, BACKBOARD_HEIGHT = 1.07, BACKBOARD_THICKNESS = 0.03;
            const backboardShape = new CANNON.Box(new CANNON.Vec3(BACKBOARD_WIDTH / 2, BACKBOARD_HEIGHT / 2, BACKBOARD_THICKNESS / 2));
            const backboardBody = new CANNON.Body({ mass: 0, shape: backboardShape, material: hoopMat });
            backboardBody.position.set(0, HOOP_HEIGHT + (BACKBOARD_HEIGHT / 2) - 0.3, -COURT_Z_LENGTH + RIM_CENTER_Z_OFFSET);
            world.addBody(backboardBody);

            const RIM_THICKNESS_COLLISION = 0.05;
            const rimShape = new CANNON.Cylinder(RIM_RADIUS, RIM_RADIUS, RIM_THICKNESS_COLLISION, 20);
            const rimBody = new CANNON.Body({ mass: 0, shape: rimShape, material: hoopMat });
            
            rimBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            rimBody.position.set(0, RIM_CENTER_Y, RIM_CENTER_Z_WORLD);
            world.addBody(rimBody);
        }

        function createBallModel(ballMat) {
            const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
            const ballMaterial = new THREE.MeshLambertMaterial({ color: 0xff8c00 }); // Orange
            ballMesh = new THREE.Mesh(ballGeometry, ballMaterial);
            ballMesh.castShadow = true;
            scene.add(ballMesh);
            
            const ballShape = new CANNON.Sphere(BALL_RADIUS);
            ballBody = new CANNON.Body({ mass: 0, shape: ballShape, material: ballMat });
            world.addBody(ballBody);
        }

        function holdBall() {
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);
            ballBody.mass = 0; 
            ballBody.updateMassProperties();
            isBallHeld = true;
            
            // Hide meter if it was visible
            document.getElementById('shot-meter-container').classList.add('hidden');
            
            // Reset shot type
            ballBody.shotType = null; 

            const tempPos = BALL_HOLD_OFFSET.clone();
            camera.localToWorld(tempPos); 
            ballMesh.position.copy(tempPos);
            ballBody.position.copy(tempPos);
        }

        function shootBall(chargeTime) {
            if (!isBallHeld) return;
            
            isBallHeld = false;
            hasScoredThisShot = false; 
            ballBody.mass = ORIGINAL_BALL_MASS; 
            ballBody.updateMassProperties();
            // FIX: Tell the physics engine to start simulating this body immediately
            ballBody.wakeUp(); 

            // Get the camera's world direction (where the player is looking)
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);

            const ballPos = ballMesh.position;
            ballBody.position.copy(ballPos); 

            // Base speed for all calculated trajectories
            const LAUNCH_POWER = 15; 
            
            let launchVector;
            let shotType;

            // --- Determine Shot Outcome based on Charge Time ---
            if (chargeTime >= SWEET_SPOT_MIN && chargeTime <= SWEET_SPOT_MAX) {
                // --- PERFECT SHOT (SWISH/MAKE) ---
                shotType = 'Make';
                launchVector = direction.clone().multiplyScalar(LAUNCH_POWER);
                launchVector.y += 3.5; 
                
                ballBody.material.restitution = 0.5; 
                
            } else if (chargeTime < SWEET_SPOT_MIN) {
                // --- UNDERCHARGED SHOT (FRONT RIM MISS) ---
                shotType = 'Miss_Front';
                launchVector = direction.clone().multiplyScalar(LAUNCH_POWER * 0.9);
                launchVector.y += 1.5; 
                
                ballBody.material.restitution = 0.7; 
                
            } else { // chargeTime > SWEET_SPOT_MAX
                // --- OVERCHARGED SHOT (BACK RIM/BACKBOARD MISS) ---
                shotType = 'Miss_Back';
                launchVector = direction.clone().multiplyScalar(LAUNCH_POWER * 1.1); 
                launchVector.y += 4.5; 
                
                ballBody.material.restitution = 0.7; 
            }

            // Store shot type on the body for scoring check
            ballBody.shotType = shotType;

            const impulse = new CANNON.Vec3(
                launchVector.x * ORIGINAL_BALL_MASS,
                launchVector.y * LAUNCH_POWER * ORIGINAL_BALL_MASS, // Use LAUNCH_POWER here for y component
                launchVector.z * ORIGINAL_BALL_MASS
            );
            
            ballBody.applyImpulse(impulse, ballBody.position);
        }
        
        // --- CAMERA LOGIC ---
        window.switchCameraView = function() {
            isThirdPerson = !isThirdPerson;
            const toggleIcon = document.getElementById('camera-icon');
            
            if (isThirdPerson) {
                // TPV Icon (User Silhouette)
                toggleIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>';
            } else {
                // FPV Icon (Pointer)
                toggleIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>';
                camera.position.set(0, 0, 0); 
                camera.rotation.set(0, 0, 0); 
            }
        }

        // --- INPUT AND MOVEMENT LOGIC ---
        function setupPlayerControls() {
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break; 
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': 
                        if (isBallHeld && !isChargingShot) {
                            isChargingShot = true;
                            shotChargeTime = 0; 
                            document.getElementById('shot-meter-container').classList.remove('hidden');
                        }
                        break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'Space': 
                        if (isChargingShot) {
                            isChargingShot = false;
                            
                            const chargeTime = shotChargeTime;
                            
                            // Hide and reset meter visuals
                            document.getElementById('shot-meter-container').classList.add('hidden');
                            document.getElementById('shot-meter-fill').classList.remove('bg-red-500', 'pulse-glow');
                            
                            shootBall(chargeTime);
                            shotChargeTime = 0; // Reset charge time
                        }
                        break;
                }
            });
            
            let isDragging = false;
            let previousMouseX = 0;

            renderer.domElement.addEventListener('mousedown', (event) => {
                if (event.target.id === 'scene-container' || event.target.tagName === 'CANVAS') {
                    isDragging = true;
                    previousMouseX = event.clientX;
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isDragging) return;

                const deltaX = event.clientX - previousMouseX;
                player.rotation.y -= deltaX * rotationSpeed; 
                previousMouseX = event.clientX;
            });
        }

        function updatePlayerMovement() {
            const tempVector = new THREE.Vector3(0, 0, 0);
            
            const forward = new THREE.Vector3();
            player.getWorldDirection(forward); 
            forward.y = 0; 
            forward.normalize();

            const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), forward).normalize(); 

            if (moveForward) tempVector.add(forward); 
            if (moveBackward) tempVector.sub(forward); 
            if (moveLeft) tempVector.sub(right); 
            if (moveRight) tempVector.add(right); 

            if (tempVector.lengthSq() > 0) {
                tempVector.normalize();
                player.position.add(tempVector.multiplyScalar(playerSpeed));
            }
            
            player.position.x = Math.max(-COURT_WIDTH + 0.5, Math.min(COURT_WIDTH - 0.5, player.position.x));
            player.position.z = Math.max(-COURT_Z_LENGTH + 0.5, Math.min(COURT_Z_LENGTH * 1.5, player.position.z));
            player.position.y = playerHeight; 
            
            // Holding Logic
            if (isBallHeld) {
                const tempPos = BALL_HOLD_OFFSET.clone();
                camera.localToWorld(tempPos); 

                ballMesh.position.copy(tempPos);
                ballBody.position.copy(tempPos);
                
                ballBody.velocity.set(0, 0, 0);
                ballBody.angularVelocity.set(0, 0, 0);
            } else {
                // Retrieval Logic
                const playerPos2D = new THREE.Vector3(player.position.x, 0, player.position.z);
                const ballPos2D = new THREE.Vector3(ballMesh.position.x, 0, ballMesh.position.z);
                const playerToBallDistSq = playerPos2D.distanceToSquared(ballPos2D);
                
                if (playerToBallDistSq < RETRIEVE_DISTANCE_SQ && ballBody.position.y < 0.5) {
                    const speed = ballBody.velocity.length();
                    if (speed < 1.5) { 
                        holdBall();
                    }
                }
            }
        }

        function checkScore() {
            if (isBallHeld || hasScoredThisShot || ballBody.shotType !== 'Make') return;

            const ballPos = ballBody.position;
            const rimY = RIM_CENTER_Y;

            // 1. Check if the ball has passed below the rim plane
            if (ballPos.y < rimY - (BALL_RADIUS / 2)) {
                
                // 2. Check lateral alignment (Ball must be roughly centered over the rim)
                const dx = ballPos.x; 
                const dz = ballPos.z - RIM_CENTER_Z_WORLD; 
                const distSqXZ = dx * dx + dz * dz;

                if (distSqXZ < (RIM_RADIUS * 1.5) * (RIM_RADIUS * 1.5)) { 
                    score++;
                    hasScoredThisShot = true;
                    document.getElementById('score-value').innerText = score;
                    // Reset ball restitution to standard for next shot
                    ballBody.material.restitution = 0.7; 
                }
            }
        }

        function updatePhysics() {
            checkScore(); 
            world.step(timeStep);

            if (!isBallHeld) {
                ballMesh.position.copy(ballBody.position);
                ballMesh.quaternion.copy(ballBody.quaternion);
            }

            if (ballBody.position.y < -5) {
                holdBall();
            }
        }


        function onWindowResize() {
            const container = document.getElementById('scene-container');
            if (container) {
                 camera.aspect = container.clientWidth / container.clientHeight;
                 camera.updateProjectionMatrix();
                 renderer.setSize(container.clientWidth, container.clientHeight);
            }
        }

        function animate() {
            animFrame = requestAnimationFrame(animate);

            // --- Shot Meter Update ---
            if (isChargingShot) {
                shotChargeTime += timeStep;
                
                const chargePercent = Math.min(shotChargeTime / MAX_SHOT_CHARGE_TIME, 1.0) * 100;
                const meterFill = document.getElementById('shot-meter-fill');
                meterFill.style.width = `${chargePercent}%`;
                
                // Visual feedback for hitting max charge (overcharge)
                if (shotChargeTime > MAX_SHOT_CHARGE_TIME) {
                    meterFill.classList.add('bg-red-500', 'pulse-glow');
                } else {
                    meterFill.classList.remove('bg-red-500', 'pulse-glow');
                    
                    // Change color to green if in sweet spot
                    if (shotChargeTime >= SWEET_SPOT_MIN && shotChargeTime <= SWEET_SPOT_MAX) {
                        meterFill.style.backgroundColor = '#10b981'; // Tailwind green-500
                    } else {
                        meterFill.style.backgroundColor = 'var(--neon-blue)'; // Neon blue
                    }
                }
            }
            
            // --- Camera Update (TPV/FPV) ---
            if (isThirdPerson) {
                camera.position.copy(TPV_CAMERA_OFFSET);
                
                const lookAtTargetWorld = new THREE.Vector3();
                player.localToWorld(TPV_LOOKAT_LOCAL.clone(), lookAtTargetWorld);
                camera.lookAt(lookAtTargetWorld);
                
            } else {
                camera.position.set(0, 0, 0); 
                camera.rotation.set(0, 0, 0); 
            }

            updatePlayerMovement();
            updatePhysics();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
